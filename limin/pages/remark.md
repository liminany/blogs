# 工作笔记、备忘，包括技术、管理等
## temp
- 允许团队成员在变革中放错，放错后不要指责，及时了解放错的根本原因，慢慢引导
- 经常站在成员的角度考虑问题，当发生冲突时，第一时间说：我能理解你的心情和情况
## 2016-06-01 回顾会议流程概要
1. 会前工作，可以先做一些基础调查表，为促进成员的沟通，先要和管理层沟通保持低调，为保证全员参与，可以找一些平时比较活跃的托带动气氛。

1. 向大家提问，对我来做主持有什么意见或者期望？指定一个人做回顾会议记录，表示会轮流执行。主持人有时候需要参与讨论，指定一个人监督，以避免陷入讨论中而忘了主持人的职责。从这里引申出SM的职责，如下：？

- 介绍回顾会议, 让团队了解回顾会议的渊源和重要性:
	1. 人类为什么会进化？【通过交流、沟通、协作来改善所学的知识，不断进步。你的（团队、组织、企业）目标是什么？通过目标驱动，动力来自于自我价值的实现，但是组织、企业不一样】。提问精益非常核心的一条原则是？ 【持续改进】，并引申出，是否需要敏捷培训，如果需要则另行安排时间培训。
	2. 如何持续改进？【不断的反思，不断的回顾】
    
   3. 我们做为一个团队，为什么要回顾？回顾的目的是？【学习团队成员优点、找到问题根源并改进、并付诸于行动】【降低交付的风险，更有效的决策，提升交付的质量，最大化交付的价值】
   
	4. 在敏捷里面，有一条原则尊重员工，其中一种解读是尊重员工的意见，保证所有人都有权利发言，回顾的过程中管理人员最好保持低调，重点放在引导成员讨论和参与决策（引导式，不断的提问），而且对于开回顾会议的时间需要尊重团队成员的意见，而不是通过领导的命令式和控制式的决策来确定时间（非工作时间），回顾会一定要在一个舒适、和谐的环境中开展，否则会大打折扣
    
	5. 提问：大家想不想进步，怎么样进步？【交流沟通协作，参与式决策】希望所有团队都参与进来，如果第一次不发言，以后也不会在有发言机会，请将不满释放出来【不要像金钟华】，引申出被动式和主动式的态度【主动式是快乐的，被动式是痛苦的，自行找出原因，不喜欢这个行业？是则无救】，因人而异，主动式者为人才，提倡主动思考，而不要像【李垠志，你叫我做什么就做什么】，同时解释为什么会有这种情况存在，是因为团队文和管理风格化所决定的，引申出命令式、控制式和引导式、仆人式的领导风格。【激励因素和保健因素，如何提高积极性？需要有环境支持
   
	6. 回顾会议是按照一定的架构一步一步进行的，不希望中途参与或者中途中断或者开小差，而且确保所有与当前项目标相关的人员都到场  
    
	10. 投票环节，可以采用扑克投票：【回顾会议的时间：5点8点？还是正常工作时间？或者建议什么时间？】【如果缺人时，投票决定是否需要等，如果是则散会或者等待】【“探索者”的投票环节】【对现状是否满足？】


- 介绍本次回顾会议的目标，分析当前项目的情况，找到问题的根源并解决他，重点关注工程实践【先从工程、技术实践做起，由内而外】。提问：大家觉得本次回顾的目标是什么？想改进哪方面的内容？
>	
	1. 原因分为内部原因和外部原因，客观原因和主观原因，根本原因和直接原因，通过5W法分析列出各种类型的原因，最终找出根本原因，并试着去解决。不要把所有原因都归结为外部问题或者客观问题，先从内部改善做起，团队无法解决的，上报管理层解决，并持续跟进


- 介绍回顾会议的议程:
>	1. 确定回顾基调和公约，设定奖罚规则，并安排人员监督
   2. 画出项目关键时间线，让大家回忆开发过程中的事件,并收集上来，事件分为好的和不好的，具体见第4、5点
	3. 归类好的地方，对成员做的好成员点赞，分析团队成员的优点或者为当前项目做出的贡献，给予鼓励和赞美，并动员其他成员学习，制定学		习计划（如果可以学习。可以在最后一步制定） ，好的地方需要保持，并定期检查
	4. 归类不好的事件，注意是事件结果，因为需要通过结果去分析根本原因 
	5. 讨论各个事件引起的原因，并提问：如果给一次重来的机会会做出怎样的决策？讨论：如何做出有效的决策？引申出 【为了达到这一目标，需要不断的学习来达到这一目标，而不是的拍脑袋来决定，即需要有探索者的精神（包括技术上和管理上）】。记录各个原因，并分析出根本原因
	6. 将问题归类，排序，选出最重要的（符合SMART原则）用于下一次改进，制定行动计划，定期检查执行情况
	7. 总结，询问感受和收获及对回顾的改进，将来如何更有效的改进回顾会议
      
   
- 确定回顾基调和公约，设定奖罚规则，并安排人员监督   

## 2016-05-11 ABP Odata WebAPI，通过postman post 新增数据，DateTime如果不按格式：【2016-05-09T00:00:00+08:00或者2016-05-09】 传递会有报下面的错误：
>{
  "error": {
    "code": "",
    "message": "The request is invalid.",
    "innererror": {
      "message": "entity : 无法将文本“2016-05-10 00:00:00”转换为正确的类型“Edm.DateTimeOffset”。\r\n",
      "type": "",
      "stacktrace": ""
    }
  }
}


解决办法：重载 ExecuteAsync（AbpODataEntityController），添加以下代码：
>			   var config = System.Web.Http.GlobalConfiguration.Configuration;
            var jsonFormatter = config.Formatters.OfType<JsonMediaTypeFormatter>().FirstOrDefault();
            //controllerContext.Configuration.Formatters.Insert(0, jsonFormatter);
 可以暂时解决，原因不详，有可能是找不到对应的JSON序列化器，采用了Odata的，不知是否与ABP 实现ODATA的方式有关。奶奶的花了一上午时间解决
 
## 2016-04-25 SequoiaDB_分布式数据库 ppt 知识点分析
[来源: SequoiaDB_分布式数据库_王涛_微软MVP ppt](http://pan.baidu.com/s/1qXOAOmo) 
参考： [数据仓库杂谈](http://blog.csdn.net/cajeep2001/article/details/8030405)

数据质量的分层测试：包括odl(源数据层)、bdl（基础数据层）、idl（接口数据层）、adl（应用数据层）

### 1.关于数据库设计--范式与反范式设计思考 [参考：范式与反范式的设计](http://www.daniel-journey.com/archives/519)

#### 反范式设计使用场景：对不可改变数据的反模式设计，如 将多张表合并成一张
#### 正范式设计使用场景：即传统的范式化设计，折表，范式化节省了存储空间，但存储空间却很便宜；范式化简化了更新，但读更普遍

### 2.关于MPP数据库massively parallel processing：是将任务并行的分散到多个服务器和节点上，在每个节点上计算完成后，将各自部分的结果汇总在一起得到最终的结果
参考： [MPP数据库 技术浅析](http://database.ctocio.com.cn/326/12953326.shtml)   [数据仓库技术中的MPP](http://www.dedecms.com/knowledge/data-base/generalized/2012/0703/2510.html)  [Hadoop将取代MPP，混合架构即将消失](http://www.d1net.com/bigdata/news/346918.html)
#### 数据仓库世界里面的 massively parallel processing 大概定义：
首先MPP 必须消除手工切分数据的工作量。 这是MySQL 在互联网应用中的主要局限性。另外MPP 的切分必须在任何时候都是平均的 ， 不然某些节点处理的时间就明显多于另外一些节点。对于工作负载是不是要平均分布有同种和异种之分，同种就是所有节点在数据装载的时候都同时转载，异种就是可以指定部分节点专门用来装载数据（逻辑上的不 是物理上） ， 而其他所有节点用来负责查询。 Aster Data 和Greenplum 都属于这种。 两者之间并没有明显的优势科研，同种的工作负载情况下，需要软件提供商保证所有节点的负载是平衡的。 而异种的工作负载可以在你觉得数据装载很慢的情况下手工指定更多节点装载数据
#### MPP数据库解决的问题与分布式数据库类似，从发展历程来说分布式数据库是从MPP演进而来的，特征如下：
- 任务并行执行;
- 数据分布式存储(本地化);
- 分布式计算;
- 私有资源;
- 横向扩展;
-  Shared Nothing架构，不共享资源


### 3.ODS与ETL,ODS 是业务数据与仓库的中间层，参考 [数据仓库之ETL漫谈](http://blog.csdn.net/heqiyu34/article/details/8502198)
ODS（Operational Data Store）介绍：

> ODS（Operational Data Store）是数据仓库体系结构中的一个可选部分，ODS具备数据仓库的部分特征和OLTP系统的部分特征，它是“面向主题的、集成的、当前或接近当前的、不断变化的”数据。
ODS是一个面向主题的、集成的、可变的、当前的细节数据集合，用于支持企业对于即时性的、操作性的、集成的全体信息的需求。
Kimball关于ODS的定义（<<数据仓库生命周期工具集>>）,–是操作型系统中的集成，用于当前、历史以及其它细节查询(业务系统的一部分)–为决策支持提供当前细节数据(数据仓库的一部分)。  参考如下图：
![](http://img.blog.csdn.net/20130918170007531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWFjazQxNTg1ODc3NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


- 在业务系统和数据仓库之间形成一个隔离层
> 一般的数据仓库应用系统都具有非常复杂的数据来源，这些数据存放在不同的地理位置、不同的数据库、不同的应用之中，从这些业务系统对数据进行抽取并不是一件容易的事。因此，ODS用于存放从业务系统直接抽取出来的数据，这些数据从数据结构、数据之间的逻辑关系上都与业务系统基本保持一致，因此在抽取过程中极大降低了数据转化的复杂性，而主要关注数据抽取的接口、数据量大小、抽取方式等方面的问题。


- 转移一部分业务系统细节查询的功能
> 在数据仓库建立之前，大量的报表、分析是由业务系统直接支持的，在一些比较复杂的报表生成过程中，对业务系统的运行产生相当大的压力。ODS的数据从粒度、组织方式等各个方面都保持了与业务系统的一致，那么原来由业务系统产生的报表、细节数据的查询自然能够从ODS中进行，从而降低业务系统的查询压力。


- 完成数据仓库中不能完成的一些功能
> 一般来说，带有ODS的数据仓库体系结构中，DW层所存储的数据都是进行汇总过的数据，并不存储每笔交易产生的细节数据，但是在某些特殊的应用中，可能需要对交易细节数据进行查询，这时就需要把细节数据查询的功能转移到ODS来完成，而且ODS的数据模型按照面向主题的方式进行存储，可以方便地支持多维分析等查询功能。在一个没有ODS层的数据仓库应用系统体系结构中，数据仓库中存储的数据粒度是根据需要而确定的，但一般来说，最为细节的业务数据也是需要保留的，实际上也就相当于ODS，但与ODS所不同的是，这时的细节数据不是“当前、不断变化的”数据，而是“历史的，不再变化的”数据。


## 2016-04-15 关于ABP、EF、MySQL的实践-有一个新项目，比较合适用ABP开发，但遇到一些问题，这里记录一下如何解决的
[关于ABP-博客园ABP专题](http://www.cnblogs.com/farb/p/ABPTheory.html)      [ABP总体介绍](http://www.cnblogs.com/mienreal/p/4528641.html)  

- 目标：基于现有数据库，通过工具生成DbContext、EF实体和实体映射，因为想生成干净的实体，试过很多方法，最终还是采用CodeSmith达成目标了。
- 数据为中心：因为国内大都是采用数据为中心的开发模式，即项目一上来就是设计数据库，鲜有以模型为中心，采用OO的方式来做分析和设计的.
- Model First：其实采用这种方式可以用Model First的方式，即 数据库->EDMX->T4模析(VS自带)->代码 来生成实体、映射和上下文代码。这种方式生成的实体映射是Data Annotations 的方式(特性来映射)，而不是二次的实体，想自己改T4模板又比较麻烦，T4模板想编辑要装一个VS插件才比较顺手，有智能感应，调试，但是收费的，最终放弃。
- [EF 5.x DbContext Fluent Generator for C#](https://visualstudiogallery.msdn.microsoft.com/5d663b99-ed3b-481d-b7bc-b947d2457e3c/)： 然后狂抓Github,发现一款t4 模板,可以通过EDMX模型文件生成 实体、映射、上下文代码---[EF 5.x DbContext Fluent Generator for C#](https://visualstudiogallery.msdn.microsoft.com/5d663b99-ed3b-481d-b7bc-b947d2457e3c/)坑爹的是这个比较旧了，不支持EF6 和VS2013、2015，然后通过上面的评论看到有人移植到EF6了 [下载地址](http://sdrv.ms/1dN6c5S),弄下来后，vs2013要改下里面的引用的VS版本（VS120COMNTOOLS）,VS2013是12，vs2015是15.一切弄好了，连上数据库（先得装[MYSQL驱动](http://dev.mysql.com/downloads/connector/net/)和[MYSQL FOR VS TOOLS](http://dev.mysql.com/downloads/windows/visualstudio/)）,这套t4模板勉强能用，缺陷就是依赖EDMX，类名和字段名按规则生成需要改模板。最终还是放弃。
- [EF Power tools](https://visualstudiogallery.msdn.microsoft.com/72a60b14-1581-4b9b-89f2-846072eff19d)：然后继续找，发现工具[EF Power tools](https://visualstudiogallery.msdn.microsoft.com/72a60b14-1581-4b9b-89f2-846072eff19d)有个反向工程的功能-通过右键项目->Entity Framework->Reverse Engine Code First->连接MySQL数据(需安装MYSQL驱动和VS工具) 来生成代码（但是不支持VS2015，[在评论中有人已经适配好](http://1drv.ms/1RWxOsb)），但是 无法自定义模板，虽然有另外一个菜单 Customize Reverse Engineer Templates 会生成t4模板到项目中，但还是然并卵，无法直接生成代码(报错，可能是模板的HOST与VS的HOST不一样)，查资料也不找到相关说明，最终还是放弃！
- [EntityFramework Reverse POCO Code First Generator](https://github.com/sjh37/EntityFramework-Reverse-POCO-Code-First-Generator)：继续抓Github，发现一款插件：[EntityFramework Reverse POCO Code First Generator](https://github.com/sjh37/EntityFramework-Reverse-POCO-Code-First-Generator),这个工具挺好的，但是但是 不支持MySQL，只支持MSSQL、SQLCE！坑！看了下代码，发下读取DB Schema是作者自己写的，又重复造轮子了。[于是给提了个问题](https://github.com/sjh37/EntityFramework-Reverse-POCO-Code-First-Generator/issues/26)，不知啥时候才支持其他库,最终放弃。
- [Code Smith](www.codesmithtools.com): 最后突发奇想，看看CodeSmith行不行，一找，我去，CodeSmith果然强大啊，不但能生成，而且支持所有主流数据库，都有源码可以修改，模板也非常好修改（添加注释，添加MYSQL支持，其实原来就支持，只是做了些修整），虽然不是t4,总之是非常的方便。最后最后 最新版还可以破解！爽！Code Smith下载：[CSDN绿色版](http://download.csdn.net/detail/yashua839/8608875),注意，最好去官方下载MSI安装包，在用下载包里面的破解工具激活，亲测试可用（千万要注意不要运行绿色版的程序，运行安装后的程序！），因为还有VS插件，与VS集成好后生成代码非常方便！正好清明假期，研究了下模板，最后成功生成漂亮的代码！模板文件晚些时候传到GitHub上去！CodeSmith在使用的过程中，有个小问题，在配置的地方把某些字段排除后(如ID，因为ID主键和其他通用的属性和映射会放在ABP基类)，会导致ID属性不生成，EF的导航属性生成会受影响！

- 总结：最后，如果能用标准的Code First方式来开发项目，也是非常不错的，这种方式个人觉得需要引入敏捷开发流程，以领域为中心的分析与设计模式，才能执行下去。但是这种方式对开发人员的要求稍高，必须一个经验丰富的Team Leader引导并主导设计过程！理想情况：识别目标、范围、价值、关键干系人->分析主要业务流程->流程需要的所有服务(单步的、组合的，或业务服务、基础设施服务)->从服务中识别领域->分析领域之间的关系->丰富领域属性状态->设计类图->分析领域行为->完整的领域模型(属性、状态、行为)->实体模型 

## 2016-04-15 领域分析方法-即DDD的战术分析
- 1 领域建模项目通常包括以下步骤(业务分析时)：
   - 首先为业务流程建模并文档化。 
   - 选择一个候选的业务流程，与业务领域专家一起使用通用语言来文档化业务流 程。 
   - 识别候选业务流程需要的所有服务。这些服务本质上可以是原子的（单步的） 或组合好的（多步的，有无工作流皆可）。它们也可以是业务（比如承保或资 金）或基础设施（比如电子邮件或工作调度）。对上一步识别的服务所使用的对象，确定并文档化其状态和行为。 一开始关注业务领域核心元素的时候，就将模型保持在高水平是非常重要的。

- 2 真实的 DDD 实现项目和其它软件开发项目所包含的阶段是一 样的。这些阶段包括：
    - 对领域进行建模 ,识别核心领域模型->识别服务(属于三种类型的哪种?)->模型状态(变化及场景)->关联模型(包含和组合)->相关的值对象->细化属性
    - 设计 
    - 开发 
    - 单元测试和集成测试 
    - 基于设计和开发来完善、重构领域模型（模型概念的持续集成（CI））。 
    - 使用更新的领域模型重复上述步骤（领域实现的 CI）。

- 3 业务规则
    - 是业务领域中的重要部分。它们定义了数据验证和其它的约束规则，这些规则 需要应用于特定业务流程场景中的领域对象。业务规则通常分为下面几类：
    - 数据验证
    - 数据转换
    - 商业决策 
    - 流程流向（工作流逻辑）
